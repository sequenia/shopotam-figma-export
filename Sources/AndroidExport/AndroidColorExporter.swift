import Foundation
import FigmaExportCore

final public class AndroidColorExporter {

    private let outputDirectory: URL
    private let fileName: URL?

    public init(outputDirectory: URL) {
        self.outputDirectory = outputDirectory
        self.fileName = nil
    }

    public init(
        outputDirectory: URL,
        fileName: URL?
    ) {
        self.outputDirectory = outputDirectory
        self.fileName = fileName
    }

    public func export(colorPairs: [AssetPair<Color>]) -> [FileContents] {
        let lightFile = makeColorsFile(colorPairs: colorPairs, dark: false)
        var result = [lightFile]

        if colorPairs.first?.dark != nil {
            let darkFile = makeColorsFile(colorPairs: colorPairs, dark: true)
            result.append(darkFile)
        }

        return result
    }

    public func exportCompose(
        colorPairs: [AssetPair<Color>]
    ) -> FileContents {
        let content = self.configureContent(
            colorPairs: colorPairs,
            outputPath: outputDirectory.absoluteString
        )

        return FileContents(
            destination: Destination(
                directory: outputDirectory,
                file: fileName!
            ),
            data: Data(content.utf8)
        )
    }

    private func configureContent(
        colorPairs: [AssetPair<Color>],
        outputPath: String
    ) -> String {
        let setNameColors: Set<String> = Set(colorPairs.compactMap {
            $0.light.name.components(separatedBy: "_").first
        })

        var dict = [String: [AssetPair<Color>]]()
        setNameColors.forEach { className in
            let properties = colorPairs.filter{
                $0.light.name.components(separatedBy: "_").first == className
            }
            if !properties.isEmpty {
                dict[className] = properties
            }
        }

        let packagePath = outputDirectory
            .absoluteString
            .components(separatedBy: "/app/")
            .last?
            .trimmingCharacters(in: CharacterSet(charactersIn: "/"))
            .replacingOccurrences(of: "/", with: ".") ?? ""

        var resultClasses = """
            // -------------------------------------------------------------------------------------------------
            //                  THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.
            //                  ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN.
            // -------------------------------------------------------------------------------------------------

            package com.shopotam.app.\(packagePath)

            import androidx.compose.runtime.Immutable
            import androidx.compose.runtime.staticCompositionLocalOf
            import androidx.compose.ui.graphics.Color


            """
        dict.forEach { (key, value) in
            let resultProperties = value.compactMap {
                var name = $0.light.name
                    .components(separatedBy: "_")
                name.removeFirst()
                let resultName = name.joined(separator: "_")

                let string = """
                        val \(resultName.lowerCamelCased()): Color\((value.last?.light.name == $0.light.name) ? "" : ",")
                    """

                return string
            }

            let result = """
                /**
                 * Группа цветов для \(key)
                 */
                @Immutable
                data class \(key.upperCamelCased())Colors(
                \(resultProperties.joined(separator: "\n"))
                )\n\n
                """

            resultClasses += result
        }
        resultClasses += self.generateColorSystem(colorSpaces: dict)
        resultClasses += """

        val LocalColorSystem = staticCompositionLocalOf<ColorSystem> {
            error("ColorSystem is not provided")
        }

        fun createColorSystem(isSystemInDarkTheme: Boolean): ColorSystem {
            return when (isSystemInDarkTheme) {
                true -> createDarkColorSystem()
                false -> createLightColorSystem()
            }
        }


        """
        resultClasses += self.generateColorStyles(colorSpaces: dict)

        return resultClasses
    }

    private func generateColorSystem(colorSpaces: [String: [AssetPair<Color>]]) -> String {
        let keys = colorSpaces.keys
        let propertiesClass = keys.compactMap {
            "    val \($0): \($0.upperCamelCased())Colors"
        }.joined(separator: "\n")

        let initsClass = keys.compactMap {
            "       override val \($0): \($0.upperCamelCased())Colors"
        }.joined(separator: ",\n")

        let resultString = """
            /**
             * Главная система цветов с группировкой
             */
            @Immutable
            sealed interface ColorSystem {
            \(propertiesClass)
            
                data class Light(
            \(initsClass)
                ): ColorSystem

                data class Dark(
            \(initsClass)
                ): ColorSystem
            }

            """

        return resultString
    }

    private func generateColorStyles(colorSpaces: [String: [AssetPair<Color>]]) -> String {
        var lightColors = [String]()
        colorSpaces.forEach{ (key: String, value: [AssetPair<Color>]) in

            let values = value.compactMap {
                var name = $0.light.name
                    .components(separatedBy: "_")
                name.removeFirst()
                let resultName = name.joined(separator: "_")

                return "        \(resultName.lowerCamelCased()) = Color(\($0.light.rgbToHex() ?? ""))"
            }

            let result = """
                \(key) = \(key.upperCamelCased())Colors(
            \(values.joined(separator: ",\n"))
                )
            """
            lightColors.append(result)
        }

        var darkColors = [String]()
        colorSpaces.forEach{ (key: String, value: [AssetPair<Color>]) in

            let values = value.compactMap {
                var name = $0.light.name
                    .components(separatedBy: "_")
                name.removeFirst()
                let resultName = name.joined(separator: "_")

                return "        \(resultName.lowerCamelCased()) = Color(\($0.dark?.rgbToHex() ?? ""))"
            }

            let result = """
                \(key) = \(key.upperCamelCased())Colors(
            \(values.joined(separator: ",\n"))
                )
            """
            darkColors.append(result)
        }


        let resultString = """
            /**
             * Значение цвета в hex требует формат в виде: "0xAARRGGBB"
             */
            private fun createLightColorSystem() = ColorSystem.Light(
            \(lightColors.joined(separator: ",\n"))
            )

            /**
             * Значение цвета в hex требует формат в виде: "0xAARRGGBB"
             */
            private fun createDarkColorSystem() = ColorSystem.Dark(
            \(darkColors.joined(separator: ",\n"))
            )
            """

        return resultString
    }

    private func makeColorsFile(colorPairs: [AssetPair<Color>], dark: Bool) -> FileContents {
        let contents = prepareColorsDotXMLContents(colorPairs, dark: dark)
        
        let directoryURL = outputDirectory.appendingPathComponent(dark ? "values-night" : "values")
        let fileURL = URL(string: "colors.xml")!
        
        return FileContents(
            destination: Destination(directory: directoryURL, file: fileURL),
            data: contents
        )
    }
    
    private func prepareColorsDotXMLContents(_ colorPairs: [AssetPair<Color>], dark: Bool) -> Data {
        let resources = XMLElement(name: "resources")
        let xml = XMLDocument(rootElement: resources)
        xml.version = "1.0"
        xml.characterEncoding = "utf-8"
        
        colorPairs.forEach { colorPair in
            if dark, colorPair.dark == nil { return }
            let name = dark ? colorPair.dark!.name : colorPair.light.name
            let hex = dark ? colorPair.dark!.hex : colorPair.light.hex
            let colorNode = XMLElement(name: "color", stringValue: hex)
            colorNode.addAttribute(XMLNode.attribute(withName: "name", stringValue: name) as! XMLNode)
            resources.addChild(colorNode)
        }
        
        return xml.xmlData(options: .nodePrettyPrint)
    }
}

private extension Color {
    func doubleToHex(_ double: Double) -> String {
        String(format: "%02X", arguments: [Int((double * 255).rounded())])
    }

    var hex: String {
        let rr = doubleToHex(red)
        let gg = doubleToHex(green)
        let bb = doubleToHex(blue)
        var result = "0x"
        if alpha != 1.0 {
            let aa = doubleToHex(alpha)
            result.append(aa)
        }

        result += "\(rr)\(gg)\(bb)"
        return result
    }

    func rgbToHex() -> String? {
        guard red >= 0 && red <= 255,
              green >= 0 && green <= 255,
              blue >= 0 && blue <= 255 else {
            return nil
        }
        return String(format: "0xFF%02X%02X%02X", Int(red), Int(green), Int(blue))
    }
}
