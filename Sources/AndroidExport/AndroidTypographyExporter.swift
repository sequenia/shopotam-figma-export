//
//  AndroidTypographyExporter.swift
//  
//
//  Created by Ivan Mikhailovskii on 12.12.2022.
//

import Foundation
import FigmaExportCore
import Utils

final public class AndroidTypographyExporter {

    private let outputDirectory: URL
    private let attributes: [TypographyAttributes]?
    private let fileName: URL?

    public init(
        outputDirectory: URL,
        attributes: [TypographyAttributes]?
    ) {
        self.outputDirectory = outputDirectory
        self.attributes = attributes
        self.fileName = nil
    }

    public init(
        outputDirectory: URL,
        attributes: [TypographyAttributes]?,
        fileName: URL?
    ) {
        self.outputDirectory = outputDirectory
        self.attributes = attributes
        self.fileName = fileName
    }

    public func makeTypographyFile(
        _ textStyles: [String: [TextStyle]]
    ) -> FileContents {
        var styles = ""
        textStyles.keys.forEach {
            styles += "    val \($0): \($0.upperCamelCased())TypographySystem,\n"
        }

        var fontFamily = ""
        FontWidthType.allCases.forEach { fontType in
            fontFamily += "    Font(R.font.roboto_\(fontType.getType().snakeCased()), weight = FontWeight.W\(Int(fontType.rawValue))),\n"
        }

        var typographySystems = ""
        textStyles.keys.forEach {
            typographySystems += "    \($0) = create\($0.upperCamelCased())TypographySystem(),\n"
        }

        let packagePath = outputDirectory
            .absoluteString
            .components(separatedBy: "/app/")
            .last?
            .trimmingCharacters(in: CharacterSet(charactersIn: "/"))
            .replacingOccurrences(of: "/", with: ".") ?? ""

        let contentFile = """
        // -------------------------------------------------------------------------------------------------
        //                  THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.
        //                  ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN.
        // -------------------------------------------------------------------------------------------------

        package com.shopotam.app.\(packagePath)

        import androidx.compose.runtime.Immutable
        import androidx.compose.runtime.staticCompositionLocalOf
        import androidx.compose.ui.text.TextStyle
        import androidx.compose.ui.text.font.Font
        import androidx.compose.ui.text.font.FontFamily
        import androidx.compose.ui.text.font.FontWeight
        import androidx.compose.ui.unit.Dp
        import androidx.compose.ui.unit.dp
        import androidx.compose.ui.unit.sp
        import com.shopotam.app.R
        
        /**
         * Класс-обертка для хранения стилей типографики
         */
        @Immutable
        data class ExtendedTextStyle(
            val textStyle: TextStyle,
            val paragraphSpacing: Dp
        )
        
        private val customFontFamily = FontFamily(
        \(fontFamily)
        )
        
        /**
         * Типографика приложения
         */
        @Immutable
        data class TypographySystem(
        \(styles)
        )

        \(generateTypographySystemClasses(textStyles))        
        val LocalTypographySystem = staticCompositionLocalOf<TypographySystem> {
            error("TypographySystem is not provided")
        }
        
        fun createTypographySystem() = TypographySystem(
        \(typographySystems)
        )
        \(generateTypographySystemContent(textStyles))
        """

        return FileContents(
            destination: Destination(
                directory: outputDirectory,
                file: fileName!
            ),
            data: Data(contentFile.utf8)
        )
    }

    private func generateTypographySystemClasses(
        _ textStyles: [String: [TextStyle]]
    ) -> String {
        var styleTypographySystem = ""
        textStyles.forEach {
            var result = "@Immutable\n"
            result += "data class \($0.key.upperCamelCased())TypographySystem(\n"

            $0.value.forEach { textStyle in
                result += "    val \(textStyle.name): ExtendedTextStyle,\n"
            }
            result += ")\n\n"
            styleTypographySystem += result
        }

        return styleTypographySystem
    }

    func generateTypographySystemContent(
        _ textStyles: [String: [TextStyle]]
    ) -> String {
        var result = ""
        textStyles.forEach {
            result += "private fun create\($0.key.upperCamelCased())TypographySystem(): \($0.key.upperCamelCased())TypographySystem {\n"
            var returnResult = "    return \($0.key.upperCamelCased())TypographySystem(\n"

            $0.value.forEach { textStyle in
                let style = """
                    val \(textStyle.name) = ExtendedTextStyle(
                        textStyle = TextStyle(
                            fontFamily = customFontFamily,
                            fontWeight = FontWeight.W\(Int(textStyle.width!)),
                            fontSize = \(Int(textStyle.fontSize)).sp,
                            lineHeight = \(Int(textStyle.lineHeight ?? .zero)).sp,
                            letterSpacing = (\(textStyle.letterSpacing)).sp,
                        ),
                        paragraphSpacing = 10.dp
                    )\n\n
                """
                returnResult += "       \(textStyle.name) = \(textStyle.name),\n"
                result += style
            }

            result += "\(returnResult)\n    )\n"
            result += "}\n\n"
        }

        return result
    }

    public func makeTypographyFile(
        _ textStyles: [TextStyle],
        colorPairs: [AssetPair<Color>],
        dark: Bool
    ) -> FileContents {
        let contents = prepareTypographyDotXMLContents(
            textStyles,
            colorPairs: colorPairs,
            dark: dark
        )

        let directoryURL = outputDirectory.appendingPathComponent(dark ? "values-night" : "values")
        let fileURL = URL(string: "style_text.xml")!

        return FileContents(
            destination: Destination(directory: directoryURL, file: fileURL),
            data: contents
        )
    }

    private func prepareTypographyDotXMLContents(
        _ textStyles: [TextStyle],
        colorPairs: [AssetPair<Color>],
        dark: Bool
    ) -> Data {

        let resources = XMLElement(name: "resources")
        let xml = XMLDocument(rootElement: resources)
        var useFontNames = [""]

        let colors = colorPairs.filter { $0.light.name.contains("text") }

        textStyles.forEach { textStyle in
            let style = XMLElement(name: "style")
            let fontName = textStyle.fontName
            let fontNameResult = fontName.replacingOccurrences(of: "-", with: "_").lowercased()

            if !useFontNames.contains(textStyle.fontName) {

                style.addAttribute(XMLNode.attribute(withName: "name", stringValue: "\(fontNameResult.upperCamelCased())") as! XMLNode)
                let itemFontFamily = XMLElement(name: "item", stringValue: "@font/\(fontNameResult)")
                itemFontFamily.addAttribute(XMLNode.attribute(withName: "name", stringValue: "android:fontFamily") as! XMLNode)

                let itemTextStyle = XMLElement(name: "item", stringValue: "normal")
                itemTextStyle.addAttribute(XMLNode.attribute(withName: "name", stringValue: "android:textStyle") as! XMLNode)

                style.addChild(itemFontFamily)
                style.addChild(itemTextStyle)
                resources.addChild(style)

                useFontNames.append(textStyle.fontName)
            }

            let styleFont = XMLElement(name: "style")
            styleFont.addAttribute(XMLNode.attribute(withName: "name", stringValue: "\(textStyle.name.capitalized)") as! XMLNode)
            styleFont.addAttribute(XMLNode.attribute(withName: "parent", stringValue: "\(fontNameResult.upperCamelCased())") as! XMLNode)

            let itemTextSize = XMLElement(name: "item", stringValue: "\(textStyle.fontSize)sp")
            itemTextSize.addAttribute(XMLNode.attribute(withName: "name", stringValue: "android:textSize") as! XMLNode)

            let itemLineHeight = XMLElement(
                name: "item", stringValue: "\(textStyle.lineHeight ?? textStyle.fontSize)sp")
            itemLineHeight.addAttribute(XMLNode.attribute(withName: "name", stringValue: "lineHeight") as! XMLNode)

            let itemLetterSpacing = XMLElement(name: "item", stringValue: "\(textStyle.letterSpacing)")
            itemLetterSpacing.addAttribute(XMLNode.attribute(withName: "name", stringValue: "android:letterSpacing") as! XMLNode)

            styleFont.addChild(itemTextSize)
            styleFont.addChild(itemLineHeight)
            styleFont.addChild(itemLetterSpacing)

            if let attributes = self.attributes {
                attributes.forEach { attribute in
                    if attribute.fonts.first(where: { $0.lowercased() == textStyle.name.lowercased() }) != nil {
                        let itemAttribute = XMLElement(name: "item", stringValue: attribute.value)
                        itemAttribute.addAttribute(XMLNode.attribute(withName: "name", stringValue: attribute.name) as! XMLNode)

                        styleFont.addChild(itemAttribute)
                    }
                }
            }

            resources.addChild(styleFont)

            colors.forEach({ color in
                let styleColor = XMLElement(name: "style")
                styleColor.addAttribute(XMLNode.attribute(
                    withName: "name",
                    stringValue: "\(textStyle.name.capitalized).\(color.light.name.upperCamelCased())"
                ) as! XMLNode)

                let itemColor = XMLElement(name: "item", stringValue: "@color/\(color.light.name)")
                itemColor.addAttribute(XMLNode.attribute(withName: "name", stringValue: "android:textColor") as! XMLNode)

                styleColor.addChild(itemColor)
                resources.addChild(styleColor)
            })
        }

        return xml.xmlData(options: .nodePrettyPrint)
    }
}
