//
//  AndroidTypographyExporter.swift
//
//
//  Created by Ivan Mikhailovskii on 12.12.2022.
//

import Foundation
import FigmaExportCore
import FigmaAPI

final public class AndroidSpaceTokensExporter {

    private let outputDirectory: URL
    private let fileName: URL?

    public init(
        outputDirectory: URL,
        fileName: URL?
    ) {
        self.outputDirectory = outputDirectory
        self.fileName = fileName
    }

    public func makeSpaceTokensFile(
        _ spaceTokens: SpaceTokens,
        roundedCategory: RoundedCategory
    ) -> FileContents {
        let contentFile = self.configFile(
            spaceTokens: spaceTokens, roundedCategory: roundedCategory
        )

        return FileContents(
            destination: Destination(
                directory: outputDirectory,
                file: fileName!
            ),
            data: Data(contentFile.utf8)
        )
    }

    private func configFile(
        spaceTokens: SpaceTokens,
        roundedCategory: RoundedCategory
    ) -> String {
        let packagePath = outputDirectory
            .absoluteString
            .components(separatedBy: "/app/")
            .last?
            .trimmingCharacters(in: CharacterSet(charactersIn: "/"))
            .replacingOccurrences(of: "/", with: ".") ?? ""

        let content = """
        // -------------------------------------------------------------------------------------------------
        //                  THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.
        //                  ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN.
        // -------------------------------------------------------------------------------------------------

        package com.shopotam.app.\(packagePath)

        import androidx.compose.runtime.Immutable
        import androidx.compose.runtime.staticCompositionLocalOf
        import androidx.compose.ui.unit.Dp
        import androidx.compose.ui.unit.dp

        /**
         * Размеры в приложении
         */
        @Immutable
        data class SizeSystem(
            val spaceTokens: SpaceTokens,
            val space: Space,
            val rounded: Rounded
        )

        @Immutable
        class SpaceTokens(space: Space) {
            val market = Market(space)
            val cms = Cms(space)
            
            \(self.createClassMarket(market: spaceTokens.layoutMobile.layout.market!))
            \(self.createCMSClass(cms: spaceTokens.layoutMobile.layout.cms!))
        }
        
        \(createRoundedCategory(roundedCategory: roundedCategory))
        
        \(createSpaceAlias(spaceValue: spaceTokens.spaceValue))
        val LocalSizeSystem = staticCompositionLocalOf<SizeSystem> {
            error("SizeSystem is not provided")
        }

        fun createSizeSystem(): SizeSystem {
            val space = Space()

            return SizeSystem(
                spaceTokens = SpaceTokens(space),
                space = space,
                rounded = Rounded()
            )
        }
        """

        return content
    }

    private func createSpaceAlias(spaceValue: SpaceValue) -> String {
        var content = "@Immutable\ndata class Space(\n"
        spaceValue.space.keys.forEach { key in
            let value = spaceValue.space[key]?.value
            content += "    val space_\(key.replacingOccurrences(of: ",", with: "_")): Dp = \(value ?? 0).dp,\n"
        }
        content += ")\n"
        return content
    }

    private func createClassMarket(market: LayoutCategory.Market) -> String {
        guard let block = market.block else { return "" }

        var content = "@Immutable\n    class Market(space: Space) {\n\n"
        content += """
                @Immutable
                data class Block(
                    val gap: Dp,
                    val top: Dp
                )

                @Immutable
                data class ProductCard(
                    val gap: Dp,
                    val top: Dp,
                    val paragraph: Dp
                )

                @Immutable
                data class Card(
                    val sliderMin: Dp,
                    val sliderMax: Dp,
                    val listingMin: Dp,
                    val listingMax: Dp
                )
                
                @Immutable
                data class Paragraph(
                    val top: Dp
                )
                
                @Immutable
                data class Form(
                    val top: Dp,
                    val gap: Dp,
                    val groupGap: Dp
                )
                
                @Immutable
                data class Section(
                    val side: Dp,
                    val largeMax: Dp,
                    val top: Dp,
                    val bottom: Dp,
                    val smallMax: Dp,
                    val sideCms: Dp
                )
        
                val block = Block(
                    gap = space.\(block.gap?.resolvedValueKeyForAndroid() ?? ""), 
                    top = space.\(block.top?.resolvedValueKeyForAndroid() ?? "")
                )
                
                val productCard = ProductCard(
                    gap = space.\(market.productcard?.gap?.resolvedValueKeyForAndroid() ?? ""),
                    top = space.\(market.productcard?.top?.resolvedValueKeyForAndroid() ?? ""),
                    paragraph = space.\(market.productcard?.pragraph?.resolvedValueKeyForAndroid() ?? "")
                )
                
                val card = Card(
                    sliderMin = \(market.card?.sliderMin?.value ?? .zero).dp,
                    sliderMax = \(market.card?.sliderMax?.value ?? .zero).dp,
                    listingMin = \(market.card?.listingMin?.value ?? .zero).dp,
                    listingMax = \(market.card?.listingMax?.value ?? .zero).dp
                )
            
                val paragraph = Paragraph(
                    top = space.\(market.paragraph?.top?.resolvedValueKeyForAndroid() ?? "")
                )
                
                val form = Form(
                    top = space.\(market.form?.top?.resolvedValueKeyForAndroid() ?? ""),
                    gap = space.\(market.form?.gap?.resolvedValueKeyForAndroid() ?? ""),
                    groupGap = space.\(market.form?.groupGap?.resolvedValueKeyForAndroid() ?? "")
                )
            
                val section = Section(
                    side = space.\(market.section?.side?.resolvedValueKeyForAndroid() ?? ""),
                    largeMax = \(market.section?.largeMax?.value ?? .zero).dp,
                    top = space.\(market.section?.top?.resolvedValueKeyForAndroid() ?? ""),
                    bottom = space.\(market.section?.bottom?.resolvedValueKeyForAndroid() ?? ""),
                    smallMax = \(market.section?.smallMax?.value ?? .zero).dp,
                    sideCms = space.\(market.section?.sideCms?.resolvedValueKeyForAndroid() ?? "")
                )
            }\n
        """
        return content
    }

    private func createCMSClass(cms: LayoutCategory.Cms) -> String {
        var content = "@Immutable\n    class Cms(space: Space) {\n\n"
        content += """
                @Immutable
                data class Card(
                    val cardMin: Dp,
                    val cardMax: Dp
                )

                @Immutable
                data class Section(
                    val largeMax: Dp,
                    val smallMax: Dp,
                    val side: Dp,
                    val gap: Dp,
                    val top: Dp,
                    val bottom: Dp
                )

                val card = Card(
                    cardMin = \(cms.card?.cardMin?.value ?? .zero).dp,
                    cardMax = \(cms.card?.cardMax?.value ?? .zero).dp
                )

                val section = Section(
                    largeMax = \(cms.section?.largeMax?.value ?? .zero).dp,
                    smallMax = \(cms.section?.smallMax?.value ?? .zero).dp,
                    side = space.\(cms.section?.side?.resolvedValueKeyForAndroid() ?? ""),
                    gap = space.\(cms.section?.gap?.resolvedValueKeyForAndroid() ?? ""),
                    top = space.\(cms.section?.top?.resolvedValueKeyForAndroid() ?? ""),
                    bottom = space.\(cms.section?.bottom?.resolvedValueKeyForAndroid() ?? "")
                )

                val gap = space.\(cms.gap?.resolvedValueKeyForAndroid() ?? "")
                val side = space.\(cms.side?.resolvedValueKeyForAndroid() ?? "")
                val top = space.\(cms.top?.resolvedValueKeyForAndroid() ?? "")
                val max = \(cms.max?.value ?? .zero).dp
                val sideEditor = space.\(cms.sideEditor?.resolvedValueKeyForAndroid() ?? "")
                val bottom = space.\(cms.bottom?.resolvedValueKeyForAndroid() ?? "")
            }
        """

        return content
    }

    private func createRoundedCategory(roundedCategory: RoundedCategory) -> String {
        var content = "@Immutable\ndata class Rounded(\n"
        roundedCategory.borderRadius?.keys.forEach { key in
            guard let value = roundedCategory.borderRadius?[key]?.value else { return }

            content += "    val borderRadius_\(key): Dp = \(value).dp,\n"
        }

        roundedCategory.outline?.keys.forEach { key in
            guard let value = roundedCategory.outline?[key]?.value else { return }

            content += "    val outline_\(key): Dp = \(value).dp,\n"
        }

        roundedCategory.conteiner2?.keys.forEach { key in
            guard let value = roundedCategory.conteiner2?[key]?.value else { return }

            content += "    val conteiner_2_\(key): Dp = \(value).dp,\n"
        }

        roundedCategory.conteiner4?.keys.forEach { key in
            guard let value = roundedCategory.conteiner4?[key]?.value else { return }

            content += "    val conteiner_4_\(key): Dp = \(value).dp,\n"
        }

        roundedCategory.conteiner6?.keys.forEach { key in
            guard let value = roundedCategory.conteiner6?[key]?.value else { return }

            content += "    val conteiner_6_\(key): Dp = \(value).dp,\n"
        }

        roundedCategory.bg1?.keys.forEach { key in
            guard let value = roundedCategory.bg1?[key]?.value else { return }

            content += "    val bg_1_\(key): Dp = \(value).dp,\n"
        }

        content += ")"
        return content
    }
}
